package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;

@Autonomous(name="Auto Mecanum Example", group="FTC")
public class AutoMecanumExample extends LinearOpMode {
    private DcMotor frontLeft = null;
    private DcMotor frontRight = null;
    private DcMotor backLeft = null;
    private DcMotor backRight = null;
    private ElapsedTime runtime = new ElapsedTime();

    @Override
    public void runOpMode() {
        // Initialize motors (names must match robot configuration)
        frontLeft  = hardwareMap.get(DcMotor.class, "Front_left");
        frontRight = hardwareMap.get(DcMotor.class, "Front_right");
        backLeft  = hardwareMap.get(DcMotor.class, "Back_left");
        backRight = hardwareMap.get(DcMotor.class, "Back_right");

        // Set motor directions (adjust as needed for your specific setup)
        frontLeft.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.REVERSE);
        frontRight.setDirection(DcMotor.Direction.FORWARD);
        backRight.setDirection(DcMotor.Direction.FORWARD);

        // Optional: set motor mode to run with encoders
        setMotorMode(DcMotor.RunMode.RUN_USING_ENCODER);

        telemetry.addData("Status", "Initialized");
        telemetry.update();

        waitForStart();
        runtime.reset();

        if (opModeIsActive()) {
            // --- Autonomous Actions ---

            // Example 1: Drive forward for 2 seconds
            drive(0.5, 0, 0, 2000); 

            // Example 2: Strafe right for 1.5 seconds
            drive(0, 0.5, 0, 1500); 

            // Example 3: Turn left for 1 second
            drive(0, 0, -0.5, 1000); 
            
            stopDrive();
        }
    }

    // Helper method to set motor power and sleep
    public void drive(double forward, double strafe, double rotate, long milliseconds) {
        double frontLeftPower = forward + strafe + rotate;
        double frontRightPower = forward - strafe - rotate;
        double backLeftPower = forward - straafe + rotate;
        double backRightPower = forward + strafe - rotate;

        // Ensure motor power is within acceptable range (-1 to 1)
        frontLeftPower = com.qualcomm.robotcore.util.Range.clip(frontLeftPower, -1.0, 1.0);
        frontRightPower = com.qualcomm.robotcore.util.Range.clip(frontRightPower, -1.0, 1.0);
        backLeftPower = com.qualcomm.robotcore.util.Range.clip(backLeftPower, -1.0, 1.0);
        backRightPower = com.qualcomm.robotcore.util.Range.clip(backRightPower, -1.0, 1.0);


        frontLeft.setPower(frontLeftPower);
        frontRight.setPower(frontRightPower);
        backLeft.setPower(backLeftPower);
        backRight.setPower(backRightPower);

        sleep(milliseconds); // Pause execution
        stopDrive();
    }
    
    // Helper method to stop all drive motors
    public void stopDrive() {
        frontLeft.setPower(0);
        frontRight.setPower(0);
        backLeft.setPower(0);
        backRight.setPower(0);
    }

    // Helper method to set motor run mode
    public void setMotorMode(DcMotor.RunMode mode) {
        frontLeft.setMode(mode);
        frontRight.setMode(mode);
        backLeft.setMode(mode);
        backRight.setMode(mode);
    }
}
